<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Tx.RV (改 v3)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Zen+Old+Mincho&display=swap" rel="stylesheet">
  <meta charset="UTF-8">
  <meta name="application-name" content="Tx.RV">
  <meta name="theme-color" content=var(--bgColor)>
  <meta name="description" content="Tx.RV">
  <meta name="keywords" content="縦書きテキストリーダー">
  <link rel="icon" href="img/logo.svg" />
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="img/ios_logo.png" />
  <script>
    window.dataLayer = window.dataLayer ||
[];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());
    gtag('config', 'G-199SL59897');
</script>
  
  <script>
    if ("serviceWorker" in navigator) {
      const swScript = `
        const CACHE_NAME = 'txrv-cache-v3';
        // HTMLファイル自身のみをプリキャッシュ
        const urlsToCache = [
          './' 
        ];
    
        self.addEventListener('install', (event) => {
          event.waitUntil(
            caches.open(CACHE_NAME)
              .then((cache) => {
                console.log('Opened cache');
                return cache.addAll(urlsToCache);
              })
              .catch((err) => {
                 console.error('Failed to cache base URL:', err);
              })
          );
        });
    
        self.addEventListener('fetch', (event) => {
          const requestUrl = new URL(event.request.url);

          // GA/GTM (ネットワークのみ。オフラインでは失敗させる)
          if (requestUrl.hostname === 'www.googletagmanager.com' ||
              requestUrl.hostname === 'www.google-analytics.com') {
            event.respondWith(
                fetch(event.request).catch(() => new Response(null, { status: 408, statusText: "Network error" }))
            );
            return;
          }
          
          // Google Fonts API (CSS) (Stale-While-Revalidate)
          if (requestUrl.hostname === 'fonts.googleapis.com') {
            event.respondWith(
              caches.open(CACHE_NAME).then((cache) => {
                return cache.match(event.request).then((cachedResponse) => {
                  const fetchPromise = fetch(event.request).then((networkResponse) => {
                    if (networkResponse && networkResponse.status === 200) {
                      cache.put(event.request, networkResponse.clone());
                    }
                    return networkResponse;
                  }).catch(() => cachedResponse); // ネットワーク失敗時はキャッシュを返す
                  return cachedResponse || fetchPromise;
                });
              })
            );
            return;
          }

          // Google Fonts (gstatic, フォント実体) (キャッシュファースト)
          if (requestUrl.hostname === 'fonts.gstatic.com') {
             event.respondWith(
                caches.match(event.request)
                  .then((response) => {
                    if (response) {
                      return response; // キャッシュから返す
                    }
                    return fetch(event.request).then((networkResponse) => {
                      return caches.open(CACHE_NAME).then((cache) => {
                         if (networkResponse && networkResponse.status === 200) {
                           cache.put(event.request, networkResponse.clone());
                         }
                         return networkResponse;
                      });
                    });
                  })
             );
             return;
          }

          // その他のリクエスト (HTML本体など) (ネットワークファースト)
          event.respondWith(
             fetch(event.request).then((networkResponse) => {
                // 正常なレスポンスのみキャッシュ
                if (networkResponse && networkResponse.status === 200) {
                   const responseToCache = networkResponse.clone();
                   caches.open(CACHE_NAME).then((cache) => {
                       cache.put(event.request, responseToCache);
                   });
                }
                return networkResponse;
             }).catch(() => {
                // ネットワークエラー時 (オフライン) はキャッシュから返す
                return caches.match(event.request);
             })
          );
        });
    
        self.addEventListener('activate', (event) => {
          const cacheWhitelist = [CACHE_NAME];
          event.waitUntil(
            caches.keys().then((cacheNames) => {
              return Promise.all(
                cacheNames.map((cacheName) => {
                  if (cacheWhitelist.indexOf(cacheName) === -1) {
                    return caches.delete(cacheName);
                  }
                })
              );
            })
          );
        });
      `;
    
      try {
        const blob = new Blob([swScript], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
    
        navigator.serviceWorker.register(swUrl, { scope: './' })
          .then((registration) => {
            console.log("Service Worker registered (inline v3) with scope:", registration.scope);
          })
          .catch((error) => {
            console.error("Service Worker registration failed:", error);
          });
      } catch (e) {
         console.error("Failed to create SW blob:", e);
      }
    }
  </script>
  <style>
    body,
    html {
      margin: 0;
padding: 0;
      overflow: hidden;
      background-color: #f4f4f4;
      font-family: serif;
      -webkit-tap-highlight-color: transparent;
}

    .view {
      display: none;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .view.active {
      display: block;
    }

    #libraryView {
      padding: 20px;
      box-sizing: border-box;
      overflow-y: auto;
      background-color: #fff;
    }

    #libraryView h1 {
      margin: 0 0 15px 0;
      font-family: "Helvetica", "serif";
      color: #555;
      border-bottom: 2px solid #eee;
      padding-bottom: 10px;
    }

    .upload-section {
      background: #fdfdfd;
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      align-items: center;
      font-family: "Helvetica", "serif";
    }

    #fileList {
      list-style-type: none;
      padding: 0;
      margin: 0;
      font-family: "Helvetica", "serif";
    }

    #fileList li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 10px;
      border-bottom: 1px solid #f0f0f0;
    }

    #fileList li:last-child {
      border-bottom: none;
    }

    .file-info {
      flex-grow: 1;
      cursor: pointer;
      line-height: 1.4;
    }

    .file-info strong {
      font-size: 1.1rem;
      color: #333;
    }

    .file-info span {
      font-size: 0.8rem;
      color: #888;
      margin-right: 10px;
    }

    .file-info .file-progress {
      font-size: 0.9rem;
      font-weight: bold;
      color: #007bff;
      margin-left: 0px;
    }

    .file-actions {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .file-actions button {
      background: none;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 5px 10px;
      cursor: pointer;
      margin-left: 5px;
      font-size: 0.8rem;
    }

    .file-actions .delete-btn {
      border-color: #e74c3c;
      color: #e74c3c;
    }

    .file-actions .delete-btn:hover {
      background: #e74c3c;
      color: white;
    }

    .file-actions .rename-btn {
      border-color: #555;
      color: #555;
    }

    .file-actions .rename-btn:hover {
      background: #555;
      color: white;
    }

    #libraryMessage {
      color: #777;
      padding: 20px 0;
      font-family: "Helvetica", "serif";
    }


    .viewer-container {
      width: 100vw;
      height: 100vh;
      writing-mode: vertical-rl;
      overflow-x: auto;
scroll-snap-type: x mandatory;
      scrollbar-width: none;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
      overflow-wrap: break-word;
      text-align: justify;
}

    .viewer-container::-webkit-scrollbar {
      display: none;
}

    .text-content {
      height: 90vh;
      padding: 5vh 0;
      column-width: 85vw;
      column-gap: 1.5em;
font-size: 1.2rem;
      letter-spacing: 0.1em;
      line-height: 1.8;
      line-break: auto;
      scroll-snap-align: start;
      color: #777;
      white-space: pre-wrap;
      position: relative;
      z-index: 1;
}

    .controls {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
background: rgba(255, 255, 255, 0.8);
      border-top: 0px solid #ccc;
      padding: 10px 15px;
      box-sizing: border-box;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
align-items: center;
      font-size: 14px;
      font-family: "Helvetica", "serif";
      z-index: 10;
      transition: transform 0.3s ease-in-out;
      border-radius: 1em 1em 0em 0;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .controls.hidden {
      transform: translateY(100%);
}

    .controls>div {
      display: flex;
      align-items: center;
      gap: 5px;
}

    .controls input[type="range"] {
      width: 100px;
}

    .progress-bar-container {
      width: 100%;
order: -1;
      padding-bottom: 5px;
    }

    #progressBar {
      width: 100%;
      margin: 0;
pointer-events: none;
    }

    /* ▼ v3 修正 ▼ uiToggleBtn と backToLibraryBtn 共通スタイル */
    .ui-toggle-btn {
      position: fixed;
top: 10px;
      /* right はインラインstyleで指定 */
      z-index: 11;
      width: 40px;
      height: 40px;
      font-size: 20px;
      color: #aaa;
      background: rgba(255, 255, 255, 0.8);
border: 0px solid #ccc;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      display: none;
      /* デフォルト非表示 */
}

    label {
      display: block;
      white-space: nowrap;
}

    input.progressbar[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
appearance: none;
    }

    input.progressbar[type="range"]::-moz-range-thumb {
      appearance: none;
display: none;
    }

    input.commonbar[type="range"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      width: 100%;
height: 25px;
      margin: 10px 0;
      background: transparent;
      cursor: pointer;
    }

    input.commonbar[type="range"]::-webkit-slider-runnable-track {
      width: 100%;
height: 8px;
      background: rgba(240, 240, 240, 0.6);
      border-radius: 4px;
      border: none;
}

    input.commonbar[type="range"]::-moz-range-track {
      width: 100%;
height: 8px;
      background: rgba(240, 240, 240, 0.6);
      border-radius: 4px;
      border: none;
}

    input.commonbar[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
appearance: none;
      margin-top: -8.5px;
      height: 25px;
      width: 12px;
      background: #ccc;
      border-radius: 20%;
      border: 1px solid #fff;
box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
      transition: background 0.2s;
}

    input.commonbar[type="range"]::-moz-range-thumb {
      appearance: none;
height: 25px;
      width: 12px;
      background: #ccc;
      border-radius: 20%;
      border: 1px solid #fff;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
transition: background 0.2s;
    }

    input.commonbar[type="range"]:hover::-webkit-slider-thumb,
    input.commonbar[type="range"]:active::-webkit-slider-thumb {
      background: #ddd;
}

    input.commonbar[type="range"]:hover::-moz-range-thumb,
    input.commonbar[type="range"]:active::-moz-range-thumb {
      background: #ddd;
}

    input.commonbar[type="range"]:focus {
      outline: none;
}

    input.commonbar[type="range"]:focus::-webkit-slider-runnable-track {
      box-shadow: 0 0 0 2px #cce5ff;
}

    input.commonbar[type="range"]:focus::-moz-range-track {
      box-shadow: 0 0 0 2px #cce5ff;
}
  </style>
</head>

<body>

  <div id="libraryView" class="view active">
    <h1>Tx.RV 書庫</h1>
    <div class="upload-section">
      <div>
        <label for="fileInput">新規ファイル：</label>
        <input type="file" id="fileInput" accept=".txt">
      </div>
      <div>
        <label for="encodingSelect">文字コード：</label>
        <select id="encodingSelect">
          <option value="shift_jis" selected>Shift_JIS</option>
          <option value="utf-8">UTF-8</option>
<option value="euc-jp">EUC-JP</option>
        </select>
      </div>
    </div>
    <ul id="fileList"></ul>
    <div id="libraryMessage">
　ようこそ、ここはTxシリーズの縦書き表示用テキストファイルビューワーである「Tx.RV」です。上の「新規ファイル」から、読みたいテキストファイルを選択してください。
　読み込んだファイルはここにキャッシュされ、次回から選択するだけで続きから読めます。文字化けしてしまう際は、エンコードを変更してみてください。
    </div>
  </div>


  <div id="readerView" class="view">
    <button class="ui-toggle-btn" id="uiToggleBtn" style="right: 60px;">・</button>
    <button class="ui-toggle-btn" id="backToLibraryBtn" style="right: 10px; font-size: 16px; padding-top: 2px; font-family: 'Helvetica', 'serif';">＜</button>
    <div class="controls" id="controlsPanel">
      <div class="progress-bar-container">
        <input type="range" class="progressbar" id="progressBar" min="0" max="100" step="0.1" value="0">
      </div>
      
      <hr style="width:100%; margin: 2px 0; border: none; border-top: 1px dashed #ccc;">
      <div>
        <label for="fontSize">文字：</label>
        <input type="range" id="fontSize" class="commonbar" min="0.8" max="3" step="0.1" value="1.2">
      </div>
      <div style="display: none;">
        <label for="columnGap">ページ間：</label>
        <input type="range" id="columnGap" class="commonbar" min="0.5" max="5" step="0.1" value="1.5">
      </div>
      <div>
        <label for="letterSpacing">文字間：</label>
<input type="range" id="letterSpacing" class="commonbar" min="0" max="1" step="0.05" value="0.1">
      </div>
      <div>
        <label for="lineHeight">行幅：</label>
        <input type="range" id="lineHeight" class="commonbar" min="1.2" max="3" step="0.1" value="1.8">
      </div>
      <div>
        <label for="flipWidth">めくり量：</label>
        <input type="range" id="flipWidth" class="commonbar" min="0.01" max="1.00" step="0.01" value="0.95" oninput="flipWidth_display.value = Number(flipWidth.value).toFixed(2)">
        <output for="flipWidth" id="flipWidth_display">0.95</output>
      </div>
      <div>
        <label for="fontFamily">フォント：</label>
        <select id="fontFamily">
<option value="serif">明朝体</option>
          <option value="Zen Old Mincho">Zen Old Mincho</option>
          <option value="sans-serif">ゴシック体</option>
        </select>
      </div>
      <div>
        <input type="checkbox" id="swapTap">
        <label for="swapTap">タップ左右入替</label>
      </div>
    </div>

    <div class="viewer-container" id="viewerContainer">
      <div class="text-content" id="textContent"></div>
    </div>
  </div>


  <script>
document.addEventListener('DOMContentLoaded', () => {

      // --- IndexedDB 関連 (v2から変更なし) ---
      let db;
      let currentFileId = null;
      let stateSaveTimer = null;
      const DB_NAME = 'TxRV_FileCache';
      const DB_VERSION = 1;
      const STORE_NAME = 'files';

      function initDB() {
        return new Promise((resolve, reject) => {
          if (!('indexedDB' in window)) {
            alert('お使いのブラウザはIndexedDBをサポートしていません。');
            return reject('IndexedDB not supported');
          }
          const request = indexedDB.open(DB_NAME, DB_VERSION);

          request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject('DB error');
          };

          request.onsuccess = (event) => {
            db = event.target.result;
            console.log('IndexedDB opened successfully.');
            resolve(db);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              const objectStore = db.createObjectStore(STORE_NAME, {
                keyPath: 'id',
                autoIncrement: true
              });
              objectStore.createIndex('fileName', 'fileName', {
                unique: false
              });
              console.log('Object store created.');
            }
          };
        });
      }

      function saveFileToDB(fileData) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.add(fileData);
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });
      }

      function getFileFromDB(id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readonly');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.get(id);
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });
      }

      function getAllFilesFromDB() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readonly');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.getAll();
          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });
      }

      function deleteFileFromDB(id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.delete(id);
          request.onsuccess = (event) => resolve();
          request.onerror = (event) => reject(event.target.error);
        });
      }

      function updateFileName(id, newName) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const getRequest = store.get(id);
          getRequest.onsuccess = () => {
            const fileData = getRequest.result;
            if (fileData) {
              fileData.fileName = newName;
              const putRequest = store.put(fileData);
              putRequest.onsuccess = () => resolve();
              putRequest.onerror = (e) => reject(e.target.error);
            } else {
              reject('File not found');
            }
          };
          getRequest.onerror = (e) => reject(e.target.error);
        });
      }

      function updateReaderState(id, position, progress, settings) {
        return new Promise((resolve, reject) => {
          if (!db) {
            return reject("DB not initialized");
          }
          const transaction = db.transaction([STORE_NAME], 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const getRequest = store.get(id);
          getRequest.onsuccess = () => {
            const fileData = getRequest.result;
            if (fileData) {
              fileData.lastPosition = position;
              fileData.progressPercent = progress;
              fileData.settings = settings;
              const putRequest = store.put(fileData);
              putRequest.onsuccess = () => resolve();
              putRequest.onerror = (e) => reject(e.target.error);
            } else {
              reject('File not found');
            }
          };
          getRequest.onerror = (e) => reject(e.target.error);
        });
      }
      // --- IndexedDB 関連 終了 ---


      // --- ▼ v3 修正 ▼ DOM取得 (backToLibraryBtn の取得位置が移動したが、IDは同じ) ---
      const libraryView = document.getElementById('libraryView');
      const readerView = document.getElementById('readerView');
      const fileList = document.getElementById('fileList');
      const libraryMessage = document.getElementById('libraryMessage');
      const backToLibraryBtn = document.getElementById('backToLibraryBtn'); // v3: 取得は同じ

      const textContent = document.getElementById('textContent');
const viewerContainer = document.getElementById('viewerContainer');
      const controlsPanel = document.getElementById('controlsPanel');
      const uiToggleBtn = document.getElementById('uiToggleBtn');
      const fileInput = document.getElementById('fileInput');
      const encodingSelect = document.getElementById('encodingSelect');
const swapTapCheckbox = document.getElementById('swapTap');
      const fontSizeSlider = document.getElementById('fontSize');
      const columnGapSlider = document.getElementById('columnGap');
      const letterSpacingSlider = document.getElementById('letterSpacing');
      const lineHeightSlider = document.getElementById('lineHeight');
const fontFamilySelect = document.getElementById('fontFamily');
      const progressBar = document.getElementById('progressBar');
      const flipWidth = document.getElementById('flipWidth');
      const flipWidthDisplay = document.getElementById('flipWidth_display');
      // --- ▲ v3 修正 ▲ ---


      // --- 設定適用ロジック (v2から変更なし) ---
      function getCurrentSettings() {
        return {
          fontSize: parseFloat(fontSizeSlider.value),
          columnGap: parseFloat(columnGapSlider.value),
          letterSpacing: parseFloat(letterSpacingSlider.value),
          lineHeight: parseFloat(lineHeightSlider.value),
          fontFamily: fontFamilySelect.value,
          swapTap: swapTapCheckbox.checked,
          flipWidth: parseFloat(flipWidth.value)
        };
      }

      function applySettings(settings) {
        fontSizeSlider.value = settings.fontSize;
        columnGapSlider.value = settings.columnGap;
        letterSpacingSlider.value = settings.letterSpacing;
        lineHeightSlider.value = settings.lineHeight;
        fontFamilySelect.value = settings.fontFamily;
        swapTapCheckbox.checked = settings.swapTap;
        flipWidth.value = settings.flipWidth;
        flipWidthDisplay.value = Number(settings.flipWidth).toFixed(2);

        textContent.style.fontSize = settings.fontSize + 'rem';
        textContent.style.columnGap = settings.columnGap + 'em';
        textContent.style.letterSpacing = settings.letterSpacing + 'em';
        textContent.style.lineHeight = settings.lineHeight;
        textContent.style.fontFamily = settings.fontFamily;
      }
      // --- 設定適用ロジック 終了 ---


      // --- ▼ v3 修正 ▼ UI切り替えロジック (ボタン表示制御) ---
      async function showLibraryView() {
        currentFileId = null;
        readerView.classList.remove('active');
        controlsPanel.classList.add('hidden');
        uiToggleBtn.style.display = 'none';
        backToLibraryBtn.style.display = 'none'; // v3: 書庫ボタンも隠す

        libraryView.classList.add('active');
        await populateLibrary();
      }

      async function openReaderView(id) {
        try {
          const fileData = await getFileFromDB(id);
          if (!fileData) {
            alert('ファイルの読み込みに失敗しました。');
            return;
          }

          currentFileId = id;
          textContent.textContent = fileData.content;
          textContent.style.color = '#333';

          libraryView.classList.remove('active');
          readerView.classList.add('active');
          uiToggleBtn.style.display = 'block';
          backToLibraryBtn.style.display = 'block'; // v3: 書庫ボタンも表示
          controlsPanel.classList.remove('hidden');
          uiToggleBtn.textContent = '・';

          const settingsToApply = fileData.settings || getCurrentSettings();
          applySettings(settingsToApply);

          viewerContainer.scrollLeft = fileData.lastPosition || 0;
          setTimeout(updateProgress, 100);

        } catch (error) {
          console.error('Error opening reader:', error);
          alert('リーダーの起動に失敗しました。');
        }
      }

      async function populateLibrary() {
        const files = await getAllFilesFromDB();
        fileList.innerHTML = '';
        if (files.length === 0) {
          libraryMessage.style.display = 'block';
        } else {
          libraryMessage.style.display = 'none';
          files.forEach(file => {
            const li = document.createElement('li');
            li.innerHTML = `
              <div class="file-info" data-id="${file.id}">
                <strong>${escapeHTML(file.fileName)}</strong>
                <br>
                <span>(${file.encoding})</span>
                <span class="file-progress">${(file.progressPercent || 0).toFixed(0)}%</span>
              </div>
              <div class="file-actions">
                <button class="rename-btn" data-id="${file.id}">名前変更</button>
                <button class="delete-btn" data-id="${file.id}">削除</button>
              </div>
            `;
            fileList.appendChild(li);
          });

          fileList.querySelectorAll('.file-info').forEach(item => {
            item.addEventListener('click', (e) => {
              const id = parseInt(e.currentTarget.dataset.id, 10);
              openReaderView(id);
            });
          });

          fileList.querySelectorAll('.delete-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
              e.stopPropagation();
              const id = parseInt(e.currentTarget.dataset.id, 10);
              if (confirm('本当にこのファイルを削除しますか？')) {
                await deleteFileFromDB(id);
                await populateLibrary();
              }
            });
          });

          fileList.querySelectorAll('.rename-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
              e.stopPropagation();
              const id = parseInt(e.currentTarget.dataset.id, 10);
              const fileData = await getFileFromDB(id);
              const currentName = fileData.fileName;

              const newName = prompt("新しいファイル名を入力してください：", currentName);
              if (newName && newName.trim() !== "" && newName !== currentName) {
                await updateFileName(id, newName.trim());
                await populateLibrary();
              }
            });
          });
        }
      }

      function escapeHTML(str) {
        return str.replace(/[&<>"']/g, function(match) {
          return {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
          }[match];
        });
      }
      // --- ▲ v3 修正 ▲ ---


      // --- プログレスバー (v2から変更なし) ---
function updateProgress() {
        const container = viewerContainer;
const scrollableWidth = container.scrollWidth - container.clientWidth;
        if (scrollableWidth <= 0) {
          progressBar.value = 0;
return;
        }
        const progress = (Math.abs(container.scrollLeft) / scrollableWidth) * 100;
progressBar.value = Math.max(0, Math.min(100, progress));
      }

      // --- 状態保存 (v2から変更なし) ---
      function saveReaderStateDebounced() {
        if (stateSaveTimer) {
          clearTimeout(stateSaveTimer);
        }
        stateSaveTimer = setTimeout(async () => {
          if (currentFileId !== null) {
            const currentPosition = viewerContainer.scrollLeft;

            const container = viewerContainer;
            const scrollableWidth = container.scrollWidth - container.clientWidth;
            let progress = 0;
            if (scrollableWidth > 0) {
              progress = (Math.abs(currentPosition) / scrollableWidth) * 100;
              progress = Math.max(0, Math.min(100, progress));
            }

            const currentSettings = getCurrentSettings();

            try {
              await updateReaderState(currentFileId, currentPosition, progress, currentSettings);
              console.log(`State saved for ${currentFileId}`);
            } catch (error) {
              console.error('Failed to save state:', error);
            }
          }
        }, 1000);
      }

      viewerContainer.addEventListener('scroll', () => {
        updateProgress();
        saveReaderStateDebounced();
      });

      [fontSizeSlider, columnGapSlider, letterSpacingSlider, lineHeightSlider, fontFamilySelect, swapTapCheckbox, flipWidth].forEach(el => {
        el.addEventListener('input', saveReaderStateDebounced);
      });
      // --- 状態保存 終了 ---


      // --- ファイル読み込み (v2から変更なし) ---
fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const selectedEncoding = encodingSelect.value;

        libraryMessage.textContent = `読み込み中... (${selectedEncoding})`;
        libraryMessage.style.color = '#777';
        libraryMessage.style.display = 'block';

        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = async (e) => {
  try {
            const buffer = e.target.result;
            const decoder = new TextDecoder(selectedEncoding);
            const text = decoder.decode(buffer);

            const fileData = {
              fileName: file.name,
              encoding: selectedEncoding,
              content: text,
              lastPosition: 0,
              progressPercent: 0,
              settings: getCurrentSettings()
            };
            const newId = await saveFileToDB(fileData);

            await openReaderView(newId);
            fileInput.value = '';

          } catch (err) {
            libraryMessage.textContent = `エラー: [${selectedEncoding}] でデコード失敗。`;
            libraryMessage.style.color = '#c00';
            console.error(err);
          }
        };
        reader.onerror = (e) => {
          libraryMessage.textContent = 'ファイル読み込みエラー。';
          libraryMessage.style.color = '#c00';
        };
      });
      // --- ファイル読み込み 終了 ---


      // --- 設定UI (v2から変更なし) ---
fontSizeSlider.addEventListener('input', () => {
        textContent.style.fontSize = fontSizeSlider.value + 'rem';
      });
columnGapSlider.addEventListener('input', () => {
        textContent.style.columnGap = columnGapSlider.value + 'em';
      });
letterSpacingSlider.addEventListener('input', () => {
        textContent.style.letterSpacing = letterSpacingSlider.value + 'em';
      });
lineHeightSlider.addEventListener('input', () => {
        textContent.style.lineHeight = lineHeightSlider.value;
      });
fontFamilySelect.addEventListener('input', () => {
        textContent.style.fontFamily = fontFamilySelect.value;
      });
      // --- 設定UI 終了 ---


      // --- トグル (v2から変更なし) ---
uiToggleBtn.addEventListener('click', () => {
        controlsPanel.classList.toggle('hidden');
        uiToggleBtn.textContent = controlsPanel.classList.contains('hidden') ? '●' : '・';
      });

      // --- 書庫に戻るボタン (v2から変更なし) ---
      backToLibraryBtn.addEventListener('click', showLibraryView);


      function turnPage(direction) {
        const isSwapped = swapTapCheckbox.checked;
let actualDirection = direction;
        if (isSwapped) {
          actualDirection = (direction === 'next') ?
'prev' : 'next';
        }
        const container = viewerContainer;
        const currentScroll = container.scrollLeft;
const maxScroll = container.scrollWidth - container.clientWidth;
        const errorMargin = 5;
        const pageWidth = container.clientWidth * parseFloat(flipWidth.value); // v3: parseFloat
        let newScrollLeft;
        
        if (actualDirection === 'next') {
          if (currentScroll >= (maxScroll - errorMargin)) return; // 既に右端
newScrollLeft = currentScroll + pageWidth;
          if (newScrollLeft > maxScroll) newScrollLeft = maxScroll; // 行き過ぎ防止
        } else {
          if (currentScroll >= errorMargin) return; // 既に左端
newScrollLeft = currentScroll - pageWidth;
          if (newScrollLeft > 0) newScrollLeft = 0; // 行き過ぎ防止
        }
        container.scrollLeft = newScrollLeft; // CSSの scroll-behavior: smooth が適用される
}
      // --- ▲ v3 修正 ▲ ---
      
      let touchStartTime = 0;
let touchStartScrollLeft = 0;
      let touchStartClientX = 0;
      const MAX_TAP_DURATION = 300;
      const MAX_TAP_MOVE_X = 15;
      const MAX_TAP_SCROLL = 10;
function handleTouchStart(e) {
        touchStartTime = Date.now();
        touchStartScrollLeft = viewerContainer.scrollLeft;
touchStartClientX = (e.touches ? e.touches[0] : e).clientX;
      }

      function handleTouchEnd(e) {
        const touchEndTime = Date.now();
const touchEndClientX = (e.changedTouches ? e.changedTouches[0] : e).clientX;
        const duration = touchEndTime - touchStartTime;
        const deltaX = Math.abs(touchEndClientX - touchStartClientX);
const deltaScroll = Math.abs(viewerContainer.scrollLeft - touchStartScrollLeft);
        if (
          duration < MAX_TAP_DURATION &&
          deltaX < MAX_TAP_MOVE_X &&
          deltaScroll < MAX_TAP_SCROLL
        ) {
          const screenWidth = window.innerWidth;
if (touchEndClientX < screenWidth * 0.4) {
            turnPage('next'); // 左タップ = 進む
} else if (touchEndClientX > screenWidth * 0.6) {
            turnPage('prev'); // 右タップ = 戻る
}
        }
      }
      const isTouchDevice = 'ontouchstart' in window ||
navigator.maxTouchPoints > 0;
      if (isTouchDevice) {
        viewerContainer.addEventListener('touchstart', handleTouchStart, {
          passive: true
        });
viewerContainer.addEventListener('touchend', handleTouchEnd);
      } else {
        viewerContainer.addEventListener('mousedown', handleTouchStart);
        viewerContainer.addEventListener('mouseup', handleTouchEnd);
}

      // --- アプリ初期化 (v2から変更なし) ---
      async function main() {
        try {
          await initDB();
          await showLibraryView();
        } catch (error) {
          console.error('Failed to initialize app:', error);
          alert('アプリケーションの初期化に失敗しました。');
        }
      }
      main();

    });
  </script>

</body>

</html>
